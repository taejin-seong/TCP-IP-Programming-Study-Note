### TCP 소켓에 존재하는 입출력 버퍼

* TCP 소켓의 데이터 송수신에는 경계가 없음.

* 따라서 서버가 한번의 **`write`** 함수호출을 통해서 40바이트를 전송해도 클라이언트는 네 번의 **`read`** 함수호출을 통해서 10바이트씩 데이터를 수신하는 것이 가능함.

* 여기서 클라이언트가 10바이트만 먼저 수신했다면, 서버가 보낸 나머지 30바이트는 **어디서 대기**하고 있는 것 일까?

  + 사실 **`write`** 함수가 호출되는 순간이 데이터가 전송되는 순간이 아니고, **`read`** 함수가 호출되는 순간이 데이터가 수신되는 순간이 아님.
  + 정확히 말하면 **`write`** 함수가 호출되는 순간 데이터는 **출력버퍼**로 이동하고, **`read`** 함수가 호출되는 순간 **입력버퍼**에 저장된 데이터를 읽어 들이게 됨.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167380363-aa78d9d3-7e9e-41a6-8ee3-aaeb094806b8.png">  
</p>  

<br>

* 위 그림에서 보듯이 **`write`** 함수가 호출되면 **출력버퍼**라는 곳에 데이터가 전달되어서 상황에 맞게 적절히 데이터를 상대방의 **입력버퍼**로 전송.

* 그러면 상대방은 **`read`** 함수호출을 통해서 입력버퍼에 저장된 데이터를 읽음.

<hr>

* 이러한 **입출력 버퍼의 특성** 몇 가지를 정리하면 다음과 같음.

  + 입출력 버퍼는 TCP 소켓 각각에 대해 **별도로** 존재함.

  + 입출력 버퍼는 소켓생성시 **자동으로** 생성됨.
  
  + 소켓을 닫아도 **출력버퍼**에 남아있는 데이터는 **계속해서 전송**이 이뤄짐.
  
  + 소켓을 닫으면 **입력버퍼**에 남아있는 데이터는 **소멸**됨.

<hr>

* 만약 클라이언트 입력버퍼 크기가 50바이트인데, 서버에서 100바이트를 전송한다면?
  
  + 입력버퍼의 크기를 초과하는 분량의 데이터 전송은 발생하지 않게 한다. 
  
  + 그러나 **TCP가 데이터의 흐름까지 컨트롤**하기 때문에 이러한 상황은 절대 일어나지 않는다.
  
    - TCP에는 **`슬라이딩 윈도우(Sliding Window)`** 라는 프로토콜이 존재.
    
    - 이 프로토콜의 역할을 대화로 표현하면 다음과 같고, 서로 대화를 주고 받으면서 데이터를 송수신하므로 버퍼가 차고 넘쳐서 데이터가 소멸되는 일이 TCP에서는 발생하지 않음.

<br>

```
소켓 A : 50바이트 까지는 보내도 괜찮아
소켓 B : OK!

소켓 A : 내가 20바이트 비웠으니깐 70바이트까지 괜찮아
소켓 B : OK!
```
