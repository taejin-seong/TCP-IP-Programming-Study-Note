### TCP의 내부 동작원리1: 상대 소켓과의 연결

<br>

* **TCP 소켓의 생성에서 소멸의 과정까지** 거치게 되는 일을 크게 나누면, **다음 세가지**로 구분이 가능.

  + 상대 소켓과의 연결
  + 상대 소켓과의 데이터 송수신
  + 상대 소켓과의 연결종료

<br>

* 먼저 **상대 소켓과의 연결**이 어떻게 이뤄지는지 설명.

  + [Shake 1] **소켓 A** : Hi! 소켓 B, 내가 전달할 데이터가 있으니 연결 좀 하자.

  + [Shake 2] **소켓 B** : Okay! 지금 나도 준비가 되었으니 언제든지 시작해도 좋다.

  + [Shake 3] **소켓 A** : Thank you! 내 요청을 들어줘서 고맙다.

* TCP 소켓은 연결설정 과정에서 총 세번의 대화를 주고 받는다. 이를 가리켜 **`Three way handshaking`** 이라 한다.

<br>

* 아래 그림은 TCP 소켓의 연결설정 과정을 나타냄.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167386991-2c2b667a-3c28-4461-8036-321148e1b6dd.png" width="367" height="466"/>  
</p> 

<br>

* 소켓은 **전 이중(Full-duplex) 방식**으로 동작하므로 양방향으로 데이터를 주고받을 수 있음. 따라서 데이터 송수신에 앞서 준비과정이 필요.

<br>

* 연결요청을 하는 호스트 A가 호스트 B에게 **`[SYN] SEQ: 1000, ACK: -`** 메세지를 전달.

  + 이는 SEQ가 1000, ACK는 비어있음을 의미.
  
  + **`SEQ 1000`** : `내가 보내는 이 패킷에 1000이라는 번호를 부여하니 잘 받았다면 다음에는 1001번 패킷을 전달하라고 내가 말해달라.`

  + 이는 **처음 연결요청**에 사용되는 메시지이기 때문에 이 메세지를 가리켜 **데이터 송수신에 앞서 전송되는 동기화 메세지**로, **`SYN`** 라 함.

<br>

* 이어서 호스트 B가 호스트 A에게 **`[SYN+ACK] SEQ: 2000, ACK: 1001`** 메세지를 전달.

  + 이는 SEQ가 2000, ACK는 1001임을 의미.
  
  + **`SEQ 2000`** : `내가 보내는 이 패킷에 2000이라는 번호를 부여하니 잘 받았다면 다음에는 2001번 패킷을 전달하라고 내가 말해달라.`

  + **`ACK 1001`** : `좀 전에 전송한 SEQ가 1000인 패킷은 잘 받았으니, 다음 번에는 SEQ가 1001인 패킷을 전송하길 바람.`
 
  + 처음 호스트 A가 전송한 패킷에 대한 `응답 메세지(ACK 1001)`과 함께 호스트 B의 데이터 전송을 위한 `동기화 메세지(SEQ 2000)`를 함께 묶어서 보내고 있음. 이러한 유형의 메세지를 가리켜 **SYN+ACK** 라 함.

<br>

* 마지막으로 호스트 A가 호스트 B에게 **`[ACK] SEQ: 1001, ACK: 2001`** 메세지를 전달.
  
  + 앞서 보낸 패킷의 SEQ가 1000이었으, 이번에는 이보다 1 증가한 1001이 부여됨. 그리고 이 패킷은 은 다음의 메세지 전달을 목적으로 전송됨. 
  
  + `좀 전에 전송한 SEQ가 2000인 패킷은 잘 받았으니, 다음 번에는 SEQ가 2001인 패킷을 전송하길 바람.`

<br>

*  이로써 호스트 A, 호스트 B 상호 간에 데이터 송수신을 위한 준비가 모두 되었음을 서로 인식하게 됨.
 
 
* 이렇듯 데이터의 송수신에 앞서, 송수신에 사용되는 패킷에 번호를 부여하고, 이 번호정보를 상대방에 알리는 이유는 데이터의 손실의 막기 위함.

* 이렇게 패킷에 번호를 부여해서 확인하는 절차를 거치기 때문에 손실된 데이터의 확인 및 재전송이 가능한 것이고, 때문에 TCP는 손실 없는 데이터의 전송을 보장함.


<br>
<br>

### TCP의 내부 동작원리2: 상대 소켓과의 데이터 송수신
