### TCP의 내부 동작원리1: 상대 소켓과의 연결

<br>

* **TCP 소켓의 생성에서 소멸의 과정까지** 거치게 되는 일을 크게 나누면, **다음 세가지**로 구분이 가능.

  + 상대 소켓과의 연결
  + 상대 소켓과의 데이터 송수신
  + 상대 소켓과의 연결종료

<br>

* 먼저 **상대 소켓과의 연결**이 어떻게 이뤄지는지 설명.

  + [Shake 1] **소켓 A** : Hi! 소켓 B, 내가 전달할 데이터가 있으니 연결 좀 하자.

  + [Shake 2] **소켓 B** : Okay! 지금 나도 준비가 되었으니 언제든지 시작해도 좋다.

  + [Shake 3] **소켓 A** : Thank you! 내 요청을 들어줘서 고맙다.

* TCP 소켓은 연결설정 과정에서 총 세번의 대화를 주고 받는다. 이를 가리켜 **`Three way handshaking`** 이라 한다.

<br>

* 아래 그림은 TCP 소켓의 연결설정 과정을 나타냄.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167386991-2c2b667a-3c28-4461-8036-321148e1b6dd.png" width="367" height="466"/>  
</p> 

<br>

* 소켓은 **전 이중(Full-duplex) 방식**으로 동작하므로 양방향으로 데이터를 주고받을 수 있음. 따라서 데이터 송수신에 앞서 준비과정이 필요.

<br>

* 연결요청을 하는 호스트 A가 호스트 B에게 **`[SYN] SEQ: 1000, ACK: -`** 메세지를 전달.

  + 이는 SEQ가 1000, ACK는 비어있음을 의미.
  
  + **`SEQ 1000`** : `내가 보내는 이 패킷에 1000이라는 번호를 부여하니 잘 받았다면 다음에는 1001번 패킷을 전달하라고 내가 말해달라.`

  + 이는 **처음 연결요청**에 사용되는 메시지이기 때문에 이 메세지를 가리켜 **데이터 송수신에 앞서 전송되는 동기화 메세지**로, **`SYN`** 라 함.

<br>

* 이어서 호스트 B가 호스트 A에게 **`[SYN+ACK] SEQ: 2000, ACK: 1001`** 메세지를 전달.

  + 이는 SEQ가 2000, ACK는 1001임을 의미.
  
  + **`SEQ 2000`** : `내가 보내는 이 패킷에 2000이라는 번호를 부여하니 잘 받았다면 다음에는 2001번 패킷을 전달하라고 내가 말해달라.`

  + **`ACK 1001`** : `좀 전에 전송한 SEQ가 1000인 패킷은 잘 받았으니, 다음 번에는 SEQ가 1001인 패킷을 전송하길 바람.`
 
  + 처음 호스트 A가 전송한 패킷에 대한 `응답 메세지(ACK 1001)`과 함께 호스트 B의 데이터 전송을 위한 `동기화 메세지(SEQ 2000)`를 함께 묶어서 보내고 있음. 이러한 유형의 메세지를 가리켜 **SYN+ACK** 라 함.

<br>

* 마지막으로 호스트 A가 호스트 B에게 **`[ACK] SEQ: 1001, ACK: 2001`** 메세지를 전달.
  
  + 앞서 보낸 패킷의 SEQ가 1000이었으, 이번에는 이보다 1 증가한 1001이 부여됨. 그리고 이 패킷은 은 다음의 메세지 전달을 목적으로 전송됨. 
  
  + `좀 전에 전송한 SEQ가 2000인 패킷은 잘 받았으니, 다음 번에는 SEQ가 2001인 패킷을 전송하길 바람.`

<br>

*  이로써 호스트 A, 호스트 B 상호 간에 데이터 송수신을 위한 준비가 모두 되었음을 서로 인식하게 됨.
 
 
* 데이터의 송수신에 앞서, 송수신에 사용되는 패킷에 번호를 부여하고, 이 번호정보를 상대방에 알리는 이유는 데이터의 손실의 막기 위함.

* 이렇게 패킷에 번호를 부여해서 확인하는 절차를 거치기 때문에 손실된 데이터의 확인 및 재전송이 가능한 것이고, 때문에 TCP는 손실 없는 데이터의 전송을 보장함.


<br>
<br>

### TCP의 내부 동작원리2: 상대 소켓과의 데이터 송수신

<br>

* 본격적으로 데이터를 송수신할 차례, 데이터 송수신의 기본방식은 다음과 같음.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167462225-647f37d9-c6cc-4a60-a92d-4b0c7f0002ef.png" width="453" height="461"/>


</p> 

<br>

* 위 그림은 호스트 A가 호스트 B에게 총 200바이트를 두 번에 나눠서(두 개의 패킷에 나눠서) 전송하는 과정.

<br>

* 호스트 A가 100바이트의 데이터를 하나의 패킷에 실어 전송하는데, **`SEQ를 1200`** 으로 부여하고 있음. 따라서 호스트 B는 이를 근거로 패킷이 제대로 수신되었음을 알려야 하기에, **`ACK 1301`** 메세지를 담은 패킷을 호스트 A에 전송하고 있음.

* 이 때 ACK 번호가 1201이 아닌 1301인 이유는 ACK 번호를 **전송된 바이트 크기**만큼 추가로 증가시켰기 때문.

  + ACK 번호를 전송된 바이트 크기만큼 추가로 증가시키지 않으면, 패킷의 전송은 확인할 수 있을지 몰라도, 패킷에 담긴 100바이트가 전부 전송되었는지, 아니면 그 중 일부가 손실되고 80바이트만 전송되었는지 알 방법이 없음.

  + 다음의 공식을 기준으로 ACK 메세지를 전송함. : **`ACK 번호 → SEQ 번호 + 전송된 바이트 크기 + 1`**

  + 마지막에 1을 더한 이유는 **`Three way handshaking`** 에서 보였듯이, 다음 번에 전달될 SEQ의 번호를 알리기 위함.

<br>
<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167464659-41f5e981-a881-44df-a2ed-8af3b5bc411d.png" width="499" height="512"/>  
</p> 

<br>

* 위 그림은 중간에 패킷이 소멸되는 상황.

<br>

* **`SEQ 1301`** 인 패킷에 100바이트 데이터를 실어서 호스트 B로 전송되고 있음을 보임. 그러나 중간에 문제가 발생해서 호스트 B에게 전송되지 못함. 

* 이러한 경우 호스트 A는 일정시간이 지나도 **`SEQ 1031`** 에 대한 ACK 메세지를 받지 못하기 때문에 재전송을 진행함. 

* 이렇듯 데이터의 손실에 대한 재전송을 위해서, TCP 소켓은 ACK 응답을 요구하는 패킷 전송 시에 **타이머를 작동 시킴.** 그리고 해당 타이머가 **`Time-out!`** 되었을 때 패킷을 재전송함.


<br>
<br>

### TCP의 내부 동작원리3: 상대 소켓과의 연결종료

<br>

* 그냥 연결을 뚝 끊어버리면, 상대방이 전송할 데이터가 남아있을 때 문제가 되기 때문에 상호간에 연결종료의 합의과정을 거침. 

* 다음은 연결종료 과정에서 주고받는 메세지를 대화로 표현.

```CSS

소켓 A : 전 연결을 끊고자 합니다.
소켓 B : 잠시만 기다리세요.

소켓 B : 네 저도 준비가 끝났습니다. 그럼 연결을 끊으시지요.
소켓 A : 네 알겠습니다.

```

<br>

* 먼저 소켓 A가 종료 메세지를 소켓 B에게 전달하고, 소켓 B는 해당 메세지의 수신을 소켓 A에게 알림.

* 그리고 이어서 소켓 B가 종료 메세지를 소켓 A에게 전달하고, 소켓 A는 해당 메세지의 수신을 소켓 B에게 알리며 종료의 과정을 마침.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/167467864-9ba5cada-ad90-4a0a-a1f0-8f61d1ec1b9f.png" width="451" height="507"/>  
</p> 

<br>

* 위 그림은 TCP 소켓의 연결종료 과정.

* 패킷 안에 삽입되어 있는 **`FIN`** 은 종료를 알리는 메세지를 의미. 즉, 상호간에 **`FIN`** 메세지를 한번씩 주고 받고서 연결이 종료됨

  + 이 과정에서 네 단계에 걸쳐서 진행되기 때문에 이를 가리켜 **`Four-way handsahking`** 이라고 부름.

* **`SEQ`** 와 **`ACK`** 의 의미는 앞서 설명한 내용과 다르지않음. 

* 다만 **`ACK 5001`** 이 호스트 A에게 두 번 전달된 것은 **`FIN`** 메세지에 포함된 **`ACK 5001`** 은 앞서 전송한 ACK 메세지가 수신된 이후로 **데이터 수신이 없었기 때문에** 재전송된 것.


<br>


### 지금 까지 TCP 프로토콜의 기본이 되는 "TCP 흐름제어(Flow Control)" 의 기본적인 개념을 설명.
