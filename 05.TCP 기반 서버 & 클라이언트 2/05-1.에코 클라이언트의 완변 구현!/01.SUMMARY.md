### 에코 서버는 문제가 없고, 에코 클라이언트만 문제가 있다.

* 이전 [에코 클라이언트의 문제점](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/edit/master/04.TCP%20%EA%B8%B0%EB%B0%98%20%EC%84%9C%EB%B2%84%20&%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%201/043.lterative%20%EA%B8%B0%EB%B0%98%EC%9D%98%20%EC%84%9C%EB%B2%84,%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EA%B5%AC%ED%98%84/02.SUMMARY.md) 참고

* 아래는 [`echo_client.c`의 58~69행](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/blob/master/04.TCP%20%EA%B8%B0%EB%B0%98%20%EC%84%9C%EB%B2%84%20%26%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%201/04-3.lterative%20%EA%B8%B0%EB%B0%98%EC%9D%98%20%EC%84%9C%EB%B2%84%2C%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EA%B5%AC%ED%98%84/echo_client.c)에 삽입된 반복문을 나타냄.

```C
while (1)
    {
        fputs("Input message(Q to quit): ", stdout);
        fgets(message, BUF_SIZE, stdin);

        ....

        write(sock, message, strlen(message));
        str_len = read(sock, message, BUF_SIZE);
        message[str_len] = 0;
        printf("Message from server: %s", message);
    }
```

* 에코 클라이언트는 문자열을 **`write`** 함수호출을 통해 한번에 전송하고, **`read`** 함수호출을 통해서 자신이 전송한 문자열 데이터를 한번에 수신하기를 원하고 있음.
* 바로 **수신하는 단위의** 문제.

<br>

### 에코 클라이언트의 해결책!

<br>

* 에코 클라이언트의 경우에는 클라이언트가 수신해야 할 데이터의 크기를 미리 알고 있기 때문에 **예를 들어서** 크기가 20바이트인 문자열을 전송했다면, 20바이트를 수신할 때 까지 반복해서 
  **`read`** 함수를 호출하면 해결 됨.
