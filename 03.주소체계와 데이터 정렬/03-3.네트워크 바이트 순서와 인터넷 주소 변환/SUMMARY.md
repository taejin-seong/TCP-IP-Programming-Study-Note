### 바이트 순서(Order)와 네트워크 바이트 순서 <br>

* **빅 엔디안(Big Endian)** 　　: 　　상위 바이트의 값을 작은 **작은** 번지수에 저장하는 방식
* **리틀 엔디안(Little Endian)** &nbsp;:　　&nbsp;상위 바이트의 값을 **큰** 번지수에 저장하는 방식

<br>

* CPU의 데이터 저장방식을 의미하는 **'호스트 바이트 순서(Host Byte Order)'** 는 CPU에 따라서 차이가 남.
  + 인텔 계열 CPU는 리틀 엔디안 방식으로 데이터를 저장.

<br>

* 빅 엔디안 시스템에 저장된 값을 리틀 엔디안 시스템에 전송하는데, 바이트 순서에 대한 문제를 고려하지 않고 데이터를 보내면 문제가 발생
* 바로 이러한 문제점 때문에 네트워크를 통해서 데이터를 전송할 때에는 통일된 기준으로 데이터를 전송하기로 약속
* 이 약속을 가르켜 **'네트워크 바이트 순서(Network Byte Order)'** 라 함.

<br>

* 네트워크 바이트 순서의 약속은 **'빅 엔디안 방식'** 으로 통일.
  + 리틀 엔디안 시스템에서는 데이터를 전송하기에 앞서 빅 엔디안의 정렬방식으로 데이터를 재정렬해야함.

<br>

### 바이트 순서의 변환(Endian Conversions)

* 바이트 순서의 변환을 돕는 함수. 
  +  **`unsigned short htons(unsigned short);`**
  +  **`unsigned short ntohs(unsigned short);`**
  +  **`unsigned short htonl(unsigned long);`**
  +  **`unsigned short ntohl(unsigned long);`**

<br>

* **h**tons에서의 **h**는 호스트(host) 바이트 순서를 의미.
* hto**n**s에서의 **n**은 네트워크(network) 바이트 순서를 의미.
* **s**는 short, **l**은 long을 의미. (리눅스에서 long형은 4byte)

<br>

* 따라서 htons 함수는 h / to / n / s 의 조합이므로 **short형 데이터를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환** 을 의미
* ntohs 함수는 **short형 데이터를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환**

<br>

* 일반적으로 뒤에 **s**가 붙는 함수는 short = 2byte 이므로 **PORT번호**의 변환에 사용 (16비트)
* 뒤에 **l**이 붙는 함수는 long = 4byte 이므로 **IP주소**의 변환에 사용 (32비트)

<br>

<hr>

* 데이터 전송하기 전에 네트워크 바이트 순서로, 데이터가 수신되었을 때 호스트 바이트 순서로 데이터를 변경할 필요없음. 
  **자동으로 변환이 이뤄짐.**
* sockaddr_in 구조체 변수에 데이터를 채울 때 이외에는 바이트 순서를 신경 쓰지 않아도 됨.
