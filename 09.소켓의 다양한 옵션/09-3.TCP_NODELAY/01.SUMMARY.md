## Nagle 알고리즘

* `Nagle 알고리즘`은 **네트워크상에서 돌아다니는 패킷들의 흘러 넘침을 막기 위해서 1984년에 제안된 알고리즘.** 

* 이는 TCP상에서 적용되는 매우 단순한 알고리즘으로써, 적용여부에 따른 데이터 송수신 방식의 차이는 다음과 같음.


<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/171999448-d7a37c8f-d29f-4a1a-a4a0-1158fa271d83.png" width="891" height="457"/>  
</p> 

<br>


* 위 그림은 문자열 "Nagle"을 `Nagle 알고리즘`을 적용해서 전송할 때와 적용하지 않고 전송할 때의 차이를 보여줌.

* 위 그림을 통해 다음의 결론을 내릴 수 있음.

<br>
  
  + **`Nagle 알고리즘은 앞서 전송한 데이터에 대한 ACK 메세지를 받아야만, 다음 데이터를 전송하는 알고리즘`**

* 기본적으로 TCP 소켓은 `Nagle 알고리즘`을 적용해서 데이터를 송수신함. 

  + 때문에 ACK가 수신될 때까지 최대한 버퍼링을 해서 데이터를 전송함. 위 그림의 왼편에서는 이러한 상황을 나타냄.

    - 문자열 "Nagle"의 전송을 위해 이를 출력버퍼로 전달함.

    - 이 때 첫 문자 'N'이 들어온 시점에서는 이전에 전송한 패킷이 없으므로 (수신할 ACK가 없으므로) 바로 전송이 이뤄짐.

    - 그리고 문자 'N'에 대한 ACK를 기다리게 되는데, 기다리는 동안 출력버퍼에는 문자열의 나머지 "agle"이 채워짐.

    - 이어서 문자 'N'에 대한 ACK를 수신하고 출력버퍼에 존재하는 데이터 "agle"을 하나의 패킷으로 구성해서 전송하게 됨. 

    - **즉, 하나의 문자열 전송에 총 4개의 패킷이 송수신되었음.**
   
    - 참고로 위 그림은 극단적인 상황의 연출로써, 시간간격을 두고 출력버퍼로 전달되는 데이터의 전송으로 이해해야함.

<br>

* `Nagle 알고리즘`을 적용하지 않은 상태에서의 문자열 "Nagle" 전송에 대하여 설명하면,

  + 문자 'N'에서 문자 'e'까지 순서대로 출력버퍼로 전달된다고 가정.
  
    - 이 상황에서 ACK의 수신에 상관없이 패킷의 전송이 이뤄지기 때문에 **출력버퍼에 데이터가 전달되는 즉시 전송이 이루어짐.**

    - 따라서 위 그림의 오른쪽에서 보이듯이 문자열 "Nagle"의 전송에는 총 10개의 패킷이 송수신될 수 있음.
 

<br>
 
 * `Nagle 알고리즘`을 적용하지 않으면 **네트워크 트래픽 (Traffic : 네트워크에 걸리는 부하나 혼잡의 정도)에는 좋지 않은 영향을 줌.**
  
   + 1 바이트를 전송하더라도 패킷에 포함되어야 하는 헤더정보의 크기가 수십 바이트에 이르기 때문.

   + 따라서 네트워크의 효율적인 사용을 위해서는 `Nagle 알고리즘`을 **반드시 적용해야함.**

<br>

* 그러나 `Nagle 알고리즘`이 항상 좋은 것은 아님.

* 전송하는 데이터의 특성에 따라서 `Nagle 알고리즘`의 적용 여부에 따른 트래픽의 차이가 크지 않으면서도 `Nagle 알고리즘`을 적용하는 것보다 데이터의 전송이 빠른 경우도 있음.

  + 대표적인 예가 **'용량이 큰 파일 데이터의 전송'**

    - `Nagle 알고리즘`을 적용하지 않아도 출력버퍼를 거의 꽉 채운 상태에서 패킷을 전송하게 됨. 따라서 패킷의 수가 크게 증가히지도 않을뿐더러, ACK를 기다리지 않고 연속해서 데이터를 전송하니 전송속도도 놀랍게 향상됨.


<br>

* 정리하면, 일반적으로 `Nagle 알고리즘`을 적용하지 않으면 속도의 향상을 기대할 수 있으나, 무조건 `Nagle 알고리즘`을 적용하지 않을 경우에는 트래픽에 상당한 부담을 주게 되어 더 좋지 않은 결과를 얻을 수 있음. 따라서 **데이터 특성을 정확히 판단하지 않은 상태에서 `Nagle 알고리즘`을 중지하는 일은 없어야함.**

<br>

## Nagle 알고리즘의 중단

* 필요하다면 `Nagle 알고리즘`도 중단시켜야함.
  
  + **`Nagle 알고리즘의 적용 여부에 따른 트래픽의 차이가 크지 않으면서도 Nagle 알고리즘을 적용하는 것보다 데이터의 전송이 빠른 경우.`** 

<br>

* 방법은 간단함. 아래의 코드에서 보이듯이 소켓옵션 `TCP_NODELAY`를 1(TRUE)로 변경해주면 됨.

```C
int opt_val = 1;
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*)&opt_val, sizeof(opt_val));
```

<br>

* 그리고 `Nagle 알고리즘`의 설정상태를 확인하려면 다음과 같이 `TCP_NODELAY`에 설정된 값을 확하면 됨.

```C
int opt_val;
socklen_t opt_len;
opt_len = sizeof(opt_val):
getsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (void*)&opt_val, &opt_len);
```

* `Nagle 알고리즘`이 설정된 상태라면 함수호출의 결과로 변수 `opt_val`에는 **0이 저장되며**, 반대로 설정 되지않은 상태라면 **1이 저장됨.**
