`SO_REUSEADDR`옵션, 그리고 그와 관련 있는 **Time-wait 상태**는 상대적으로 중요함. 따라서 반드시 이해하고 기억해 둘 필요가 있음. 

<br>

## 주소할당 에러(Binding Error) 발생 <br>

* [reuseadr_esever.c](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/blob/master/09.%EC%86%8C%EC%BC%93%EC%9D%98%20%EB%8B%A4%EC%96%91%ED%95%9C%20%EC%98%B5%EC%85%98/09-2.SO_REUSEADDR/reuseadr_eserver.c) 예제를 참고하여 설명.

  + [04-3.lterative 기반의 서버, 클라이언트 구현](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/tree/master/04.TCP%20%EA%B8%B0%EB%B0%98%20%EC%84%9C%EB%B2%84%20%26%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%201/04-3.lterative%20%EA%B8%B0%EB%B0%98%EC%9D%98%20%EC%84%9C%EB%B2%84%2C%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%20%EA%B5%AC%ED%98%84)의 에코 클라이언트와 함께 실행하면 됨.

<hr>

* **클라이언트가 먼저 연결종료를 요청하는 경우는 매우 일반적인 상황이기 때문에 별다른 일이 발생할 것이 없음.** 
  
  + 서버의 재실행도 전혀 문제되지 않음.

  + 클라이언트 측에서 서버 측으로 종료를 먼저 알리게끔 하면, 서버 측으로 **`FIN`** 메세지를 먼저 전송하면서 **`Four-way handshaking`** 과정을 거치게 됨. [참고](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/blob/master/05.TCP%20%EA%B8%B0%EB%B0%98%20%EC%84%9C%EB%B2%84%20%26%20%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%202/05-2.TCP%EC%9D%98%20%EC%9D%B4%EB%A1%A0%EC%A0%81%EC%9D%B8%20%EC%9D%B4%EC%95%BC%EA%B8%B0!/02.SUMMARY.md)

  + 클라이언트 프로그램을 강제종료 할 경우에도 OS가 파일 및 소켓을 모두 닫아주는데 이 과정에서 **`close`** 함수를 호출한 것과 마찬가지로 서버 측에서 **`FIN`** 메세지가 전달됨.

<br>

* 그러나 **다음과 같이 프로그램을 종료하면** 이야기는 달라짐.

  + 서버와 클라이언트가 연결된 상태에서 서버 측 콘솔에서 CTRL+C를 입력한다. **`즉, 서버 프로그램을 강제 종료한다.`**

    - 이는 서버가 클라이언트 측으로 **`FIN`** 메세지를 전달하는 상황의 연출을 위한 것.

    - 그런데 이렇게 서버를 종료하면 서버의 재실행에 문제가 생김. 동일한 PORT번호를 기준으로 서버를 재실행하면 `"bind() error"` 라는 메세지가 출력될 뿐 서버는 실행되지 않음.

    - 그러나 이 상태에서 약 3분 정도 지난 다음 재실행을 하면 정상적인 실행을 확인할 수 있음.

<br>

* 앞서 보인 두 가지 실행방식에 있어서 유일한 차이점은 **`FIN` 메세지를 누가 먼저 전송했는지에 있음.**

* 그럼에도 불구하고 이렇게 차이를 보이는 이유에 대하여 설명함.

<br>

## Time-wait 상태 <br>

* 먼저 다음의 **`Four-way handshaking`** 과정을 살펴보도록 함.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/171916152-6d640efb-f6ed-4f8b-b2b6-3936d0e7cb15.png" width="510" height="532"/>  
</p> 

<br>

* 위의 그림은 **Time-wait 상태**의 소켓

* 호스트 A를 서버라고 보면, 호스트 A가 호스트 B로 **`FIN`** 메세지를 먼저 보내고 있으니, 서버가 콘솔창에서 CTRL+C를 입력한 상황이라고 볼 수 있음.

* 여기서 주목할 점은 연결의 해제 과정인 **`Four-way handshaking`** 이후에 소켓이 바로 소멸되지않고 **Time-wait 상태**라는 것을 일정시간 거쳐간다는 것.

  + 물론 **Time-wait 상태**는 먼저 연결의 종료를 요청한 (**`FIN`** 메세지를 전송한) 호스트만 거침.

  + **`이 때문에 서버가 먼저 연결의 종료를 요청해서 종료하고 나면, 바로 이어서 실행할 수 없는 것.`**

    - **소켓이 Time-wait 상태에 있는 동안에는 해당 소켓의 PORT번호가 사용중인 상태이기 때문.**

    - 따라서 앞서 확인한 것처럼 **`bind`** 함수 호출과정에서 오류가 발생하는 것은 당연함.

<br>

* 추가적으로 소켓의 **Time-wait 상태**는 클라이언트냐 서버냐에 상관없이 존재함. 먼저 연결의 종료를 요청하면 해당 소켓은 반드시 **Time-wait 상태**를 거침.

* **`그러나 클라이언트의 Time-wait 상태는 신경을 쓰지 않아도 됨.`**

   + 왜냐하면 클라이언트 소켓의 PORT번호는 **임의로 할당되기 때문**

   + 즉, 서버와 달리 **프로그램이 실행될 때마다 PORT번호가 유동적으로 할당됨.**

<br>


* **Time-wait 상태**가 존재하는 이유는 다음과 같음.

  + 위의 그림에서 호스트 A가 호스트 B로 마지막 ACK 메세지(SEQ 5001, ACK 7502)전송하고 나서 소켓을 바로 소멸시켰다고 가정해보자.

  + 그런데 이 마지막 ACK 메세지가 호스트 B로 전달되지 못하고 중간에 소멸되버렸다면 호스트 B는 자신이 보낸 FIN 메세지(SEQ 7501, ACK 5001)가 호스트 A에 전송되지 못했다고 생각하고 재전송을 시도 함. 
    
  + 그러나 호스트 A의 소켓은 완전히 종료된 상태이기 때문에 호스트 B는 호스트 A로부터 영원히 마지막 ACK 메세지를 받지 못하게됨.

* 반면 호스트 A의 소켓이 **Time-wait** 상태로 놓여있다면 호스트 B는 마지막 ACK 메세지를 재전송하게 되고, 호스트 B는 **정상적으로 종료할 수 있게 됨.**

<br>

* 즉, 이러한 이유로 **`FIN`** 메세지를 전송한 호스트의 소켓은 **Time-wait** 과정을 거침 
