<br>

TCP에서는 연결과정보다 중요한 것이 **종료과정** <br>
**종료과정**에서는 예상치 못한 일이 발생할 수 있기 때문에 **종료과정**은 명확해야 하고, 이를 위해 **`Hlaf-close`** 는 반드시 알야할 내용. <br>

<br>

### 일방적인 연결종료의 문제점 <br>

* 리눅스의 **`close`** 함수호출과 윈도우의 **`closesocket`** 함수호출은 **완전종료**를 의미함.

* **완전종료**라는 것은 데이터를 전송하는 것은 물론, 수신하는 것 조차 더 이상 불가능한 상황을 의미함.

* 때문에 한쪽에서의 일방적인 **`close`** 또는 **`closesocket`** 함수호출은 고급스럽지 못함.

<br>

<p align="center">
 <img src="https://user-images.githubusercontent.com/70312248/168329168-3f873b36-c464-4ac1-9e08-a6d46085fa91.png" width="577" height="155"/>  
</p>

<br>

* 위 그림은 양방향으로 통신하고 있는 두 호스트의 상황을 묘사한 것.

  + 호스트 A가 마지막 데이터를 전송하고 나서 **`close`** 함수의 호출을 통해 연결을 종료한 상황.

  + 그 이후부터는 호스트 A는 호스트B가 전송하는 데이터를 수신하지 못하며, **데이터 수신과 관련된 함수의 호출 자체가 불가능해짐.**

    - 결국엔 호스트 B가 전송한, 호스트 A가 반드시 수신해야 할 데이터라 할지라도 그냥 **소멸**되버림.

<br>

* 이러한 문제를 해결하기 위해서 **데이터의 송수신에 사용되는 스트림의 일부만 종료** **`(Half-close)`** **하는** 방법이 제공됨.

* 일부를 종료한다는 것은 **`전송은 가능하지만 수신은 불가능한 상황`**, 혹은 **`수신은 가능하지만 전송은 불가능한 상황`** 을 뜻함.
  
  + 말 그대로 스트림의 반만 닫는 것.

<br>

### 소켓과 스트림(Stream) <br>

* **소켓을 통해 두 호스트가 연결되면, 그 다음부터는 상호간에 데이터의 송수신이 가능한 상태가 됨.**

* 그리고 이러한 상태를 가리켜 **`스트림이 형성된 상태`** 라 함.

* 즉, 두 소켓이 연결되어서 데이터의 송수신이 가능한 상태를 일종의 **`스트림`** 으로 보는 것.

<br>

<p align="center">
 <img src="https://user-images.githubusercontent.com/70312248/168333124-10556d36-3954-4e13-b9c8-b5c977eca77f.png" width="845" height="252"/>  
</p>

<br>

* 소켓의 **`스트림`** 은 한쪽 방향으로만 데이터의 이동이 가능하기 때문에 위 그림과 같이 **양방향 통신을 위해서는 두 개의** **`스트림`** **이 필요.**

* 두 호스트간에 소켓이 연결되면, 각 호스트 별로 **`입력 스트림`** 과 **`출력 스트림`** 이 형성됨.  물론,

  + **한 호스트**의 **`출력 스트림`** 은 **다른 호스트의** **`입력 스트림`** 으로, 

  + **한 호스트의** **`입력 스트림`** 은 **다른 호스트의** **`출력 스트림`** 으로 이어진다.


<br>

### 우아한 종료를 위한 shutdown 함수 <br>

* **`Half-close`** 에 사용되는 함수를 소개. 

* 아래의 **`shutdown`** 함수가 **`스트림`** 의 일부를 종료하는데 사용되는 함수.

```C
#include <sys/socket.h>

/* @return : 성공 시 0, 실패 시 -1 반환
 * @param  :     sock : 종료할 소켓의 파일 디스크립터 전달.
 *              howto : 종료방법에 대한 정보 전달.
 */
int shutdown(int sock, int howto);
```

* 위 함수호출 시 두 번째 매개변수에 전달되는 인자에 따라서 종료의 방법이 결정됨. 
  
  + 두 번째 매개변수에 전달될 수 있는 인자의 종류는 다음과 같음.
  
    - **`SHUT_RD`**   : 입력 스트림 종료

    - **`SHUT_WR`**   : 출력 스트림 종료

    - **`SHUT_RDWR`** : 입출력 스트림 종료

<br>
<hr>
<br>

* **`SHUT_RD`** 가 전달되면 더 이상 데이터를 수신할 수 없는 상태가 됨.  데이터가 입력버퍼에 전달되더라도 그냥 **지워져**버릴 뿐만 아니라 **입력관련 함수의 호출도 더 이상 허용이 안됨.**

<br>

* **`SHUT_RD`** 가 전달되면 더 이상의 데이터 전송이 불가능해짐. 단, **출력 버퍼에 아직 전송되지 못한 상태로 남아있는 데이터가 존재하면 해당 데이터는 목적지로 전송됨.**

<br>

* **`SHUT_RD`** 가 전달되면 함수 한번은 **`SHUT_RD`** 를 인자로, 또 한번은 **`SHUT_WR`** 을 인자로 두 번 호출한 것과 같음. 

<br>
<hr>
<br>

### Half-close가 필요한 이유 <br>

* 아래와 같은 상황을 생각해보자.

```
클라이언트가 서버에 접속하면 서버는 약속된 파일을 클라이언트에게 전송하고, 
클라이언트는 파일을 잘 수신했다는 의미로 문자열 "Thank you"를 서버에 전송한다.
```

* 즉, **연결종료 직전에 클라이언트가 서버에 전송해야 할 데이터가 존재하는 상황으로 확대해석** 하면, 이 상황에 대한 프로그램의 구현은 그리 간단하지만은 않음. ( 블로킹 상태에 빠질 수 있기 때문.)

* 이러한 문제의 해결을 위해서 서버는 파일의 전송이 끝났음을 알리는 목적의 **`EOF`** 를 마지막에 전송해야함.

  + 클라이언트는 **`EOF`** 수신을 함수의 반환 값을 통해서 확인이 가능하기 때문에 파일에 저장된 데이터와 중복될 일도 없음.

<br>

* 여기서, 서버는 어떻게 **`EOF`** 를 전달 할 수 있을까?

<br>

* **`출력 스트림`을 종료하면 상대 호스트로 `EOF`가 전송됨.**

   + **`close`** 함수호출을 통해서 입출력 스트림을 모두 종료해줘도 **`EOF`** 는 전송되지만, 이럴 경우 상대방이 전송하는 데이터를 더 이상 수신 못한다는 문제가 발생.
  
      - 즉, **`close`** 함수호출을 통해서 **`스트림`** 을 종료하면 클라이언트가 마지막으로 보내는 문자열 "Thank you"를 수신할 수 없음.

* 따라서 **`shutdown`** 함수호출을 통해서 서버의 **`출력 스트림`** 만 **`Half-close`** 해야 함. 

  + 이럴 경우 **`EOF`** 도 전송되고, **`입력 스트림`** 은 여전히 살아있어서 데이터의 수신도 가능함.

<br>

### Half-close 기반의 파일전송 프로그램 <br>

* 위에서 언급한 파일전송 서버, 클라이언트의 데이터 흐름을 정리하면 아래와 같음. 

<br>

<p align="center">
 <img src="https://user-images.githubusercontent.com/70312248/168340524-b6d2d16f-983d-491b-872d-1f25b449f409.png" width="436" height="454"/>  
</p>

<br>
