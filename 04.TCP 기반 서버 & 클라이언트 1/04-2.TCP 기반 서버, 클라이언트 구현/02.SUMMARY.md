### TCP 클라이언트의 기본적인 함수호출 순서

* 서버의 구현과정과 비교해서 차이가 있는 부분은 **연결 요청**이라는 과정.
* 이는 클라이언트 소켓을 생성한 후에 서버로 연결을 요청하는 과정.

```java
   socket()     /* 소켓생성 */
      ↓
   connect()     /* 연결요청 */
      ↓
read()/write()  /* 데이터 송수신 */
      ↓
   close()      /* 연결종료 */
```

<br>

* 서버는 **`listen`** 함수를 호출한 이후부터 연결요청 대기 큐를 만들어 놓음. 따라서 그 이후 부터 클라이언트는 연결요청이 가능. 
* 다음 함수호출을 통해서 연결요청을 함.

```C
#include <sys/socket.h>

/* @return : 성공 시 0, 실패 시 -1 반환
 * @param  :     sock : 클라이언트 소켓의 파일 디스크립터 전달. 
 *           servaddr : 연결요청 할 서버의 주소정보를 담은 변수의 주소 값 전달.
 *            addrlen : 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달.
 */
 int connect(int sock, struct sockaddr * servaddr, socklen_t addrlen);
```

* 클라이언트에 의해서 connect 함수가 호출되면 다음 둘 중 한가지 상황이 되어야 함수가 반환됨.(함수호출이 완료됨.)

  + 서버에 의해 **연결요청이 접수**되는 상황. 
    - **연결요청의 접수**는 **`accept`** 함수호출을 의미하는 것이 아니라 클라이언트 연결요청 정보가 서버의 **연결요청 대기 큐**에 등록된 상황을 의미.
    - 따라서 **`connect`** 함수가 반환했더라도 당장에 서비스가 이뤄지지 않을 수도 있음.
  + 네트워크 단절 등 오류상황이 발생해서 **연결요청이 중단**되는 상황.

<hr>
<br>

* 클라이언트 소켓의 주소정보는 서버의 **`bind`** 함수를 통해서 소켓에 IP와 PORT를 직접 할당하지 않아도 connect 함수호출 시 자동으로 소켓에 IP와 PORT가 할당됨.
