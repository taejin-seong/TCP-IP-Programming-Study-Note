## 두 가지 유형의 서버 

* 다음과 같은 유형의 서버가 있다면 어떠한 유형의 서버가 좋을까?

  - `첫 번째 연결요청자의 접속대기시간은 0초, 50번째 연결요청자의 접속대기시간은 50초 그리고 100번째 연결요청자의 접속대기시간은 100초
     그러나 일단 연결만 되면 1초 안에 서비스를 완료`
     
  - `모든 연결요청자의 접속대기시간은 1초을 넘기지 않음 그러나 서비스를 제공받는데 걸리는 시간은 평균적으로 2~3초 정도 걸림.`

* 후자의 형태로 서비스를 제공하는 것이 좋음.

<br>

## 다중접속 서버의 구현방법들

* 전체적인 서비스 제공시간이 조금 늦더라도 연결요청을 해오는 **모든 클라이언트에게 동시에 서비스를 제공해서 평균적인 만족도를 높일 필요가 있음.**

* 그리고 네트워크 프로그램은 CPU의 연산을 필요치 않는 데이터의 송수신 시간이 큰 비중을 차지하므로, **둘 이상의 클라이언트에게 동시에 서비스를 제공하는 것이 CPU를 보다 효율적으로 사용하는 방법이 됨.**

* 둘 이상의 클라이언트에게 동시에 서비스를 제공하는 **다중접속 서버에 대해 논의함.**
<br>

* 다음은 대표적인 다중접속 서버의 구현 모델 및 구현 방법
  
    + **`멀티프로세스 기반 서버`** : 다수의 프로세스를 생성하는 방식으로 서비스를 제공

    + **`멀티플렉싱 기반 서버`**   : 입출력 대상을 묶어서 관리하는 방식으로 서비스를 제공

    + **`멀티쓰레딩 기반 서버`**   : 클라이언트의 수만큼 쓰레드를 생성하는 방식으로 서비스를 제공

<br>

* 첫 번째 **`멀티프로세스 기반 서버`** 의 서버 구현에 대해서 먼저 설명

  + Windows에서 지원하지 않는 방식이기 때문에 Linux에 초점을 맞출 수 밖에 없음.

<br>

## 프로세스(Process)의 이해

* 프로세스는 간단히 다음과 같이 정의할 수 있음
  
  + **`메모리 공간을 차지한 상태에서 실행중인 프로그램`**


* `프로그램`은 메인 메모리(ex) RAM)로 이동해 실행을 위한 준비를 마치게 되는데, 바로 이 시점부터 `프로세스`라 부를 수 있게 됨.

  + 만약 `프로그램`을 둘 이상 동시에 실행하게 되면, 실행하는 수만큼 `프로세스`는 생성됨. (실행되는 수만큼 메모리 공간을 차지하기 때문) 

<br>

* 만약 현재 문서작업을 해야한다고 가정해 보면 문서편집관련 프로그램을 하나 더 띄어야 하고 뿐만 아니라, 음악을 들으면서 작업하길 원하면 음악 재생기도 하나 띄워야함.
  거기에 친구와 연락하기 위해 메신저도 하나 띄운다면 `총 세 개의 프로세스를 동시에 생성하는` 셈이 됨.
  
* 이렇듯 `프로세스`는 운영체제의 관점에서 **프로그램 흐름의 기본 단위**가 되며, 여러 개의 프로세스가 생성되면 이들은 동시에 실행이 됨.

<br>

* 그러나 **하나의 프로그램이 실행되는 과정에서 여러 개의 프로세스가 생성되기도 함.**

  + **`멀티 프로세스 기반의 서버`** 가 대표적인 예

<br>

## 프로세스 ID

* 모든 `프로세스`는 생성되는 형태에 상관없이 운영체제로부터 **ID**를 부여받는다. 그리고 이를 가르켜 **`프로세스 ID`** 라 함.

  + 이는 2 이상의 정수 형태를 띰.

    - 참고로 숫자 1은 운영체제가 시작되지마자 실행되는 (운영체제의 실행을 돕는) 프로세스에게 할당되기 때문에 유저가 만들어내는 `프로세스`는 1이라는 값의 ID를 받을 수 없음.

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/172665293-f3def87a-59a1-49a6-9ebf-544863958719.png" width="850" height="481"/>  
</p> 

<br>

* 위에서 보이는 바와 같이 Linux의 **`ps 명령어`** 를 통해서 실행중인 프로세스를 간단히 확인할 수 있음.

* 특히 **`PID (Process ID)`** 도 함께 보이고 있음을 주목. 

  + 참고로 **`ps 명렁어`** 에 옵션 `a`와 `u`를 지정해서 모든 프로세스에 대한 다양한 정보를 확인할 수 있게 함.

<br>

## fork 함수호출을 통한 프로세스의 생성

* 프로세스 생성에는 몇 가지 방법이 있으나 여기서는 **`멀티프로세스 기반`** 서버의 구현에 사용되는 **`fork`** 함수에 대해 설명함.

```C
#include <unistd.h>

/*@return : 성공 시 프로세스 ID, 실패 시 -1 반환
 *
 */
pid_t fork(void);
```

* **`fork`** 함수는 호출한 프로세스의 복사본을 생성함.

  + 즉, 전혀 새로운 다른 프로그램을 바탕으로 프로세스를 생성하는 것이 아니라 **이미 실행중인,** **`fork`** **함수를 호출한 `프로세스`를 복사하는 것.**

  + 그리고는 **두 프로세스 모두** **`fork`** **함수의 호출 이후 문장을 실행하게 됨.** (정확히는 **`fork`** 함수의 반환 이후)

* 그런데 완전히 동일한 `프로세스`로, 메모리 영역까지 동일하게 복사하기 때문에 이후의 `프로그램 흐름`은 **`fork`** 함수의 반환 값을 기준으로 나뉘도록 프로그래밍을 해야함.

  + 즉, **`fork`** 함수의 다음 특징을 이용해서 `프로그램의 흐름`을 구분해야 함.

    - **`부모 프로세스`** : **`fork`** 함수의 반환 값은 자식 프로세스의 ID
    
    - **`자식 프로세스`** : **`fork`** 함수의 반환 값은 0

<br>

* 여기서 **`부모 프로세스 (Parent Process)`** 란 **원본 프로세스**, 즉 **`fork`** 함수를 호출한 주체.

* 반면 **`자식 프로세스 (Child Process)`** 란 부모 프로세스의 **`fork`** 함수을 통해서 **복사된 프로세스**를 의미.

<br>

<br>

<p align="center">
   <img src="https://user-images.githubusercontent.com/70312248/172672016-9989bfb0-a3fe-4c4c-ac36-9577bc555808.png" width="730" height="343"/>  
</p> 

<br>

* **`fork`** 함수의 호출 이후 실행의 흐름을 정리하면 다음과 같음.

* 위 그림에서 보이듯이 **`부모 프로세스`** 가 **`fork`** 함수를 호출하는 순간 **`자식 프로세스`** 가 복사되어 각각이 **`fork`** 함수호출의 반환 값을 받게 됨.

* 그런데 복사 이전에 **`부모 프로세스`** 가 전역변수 `gval`의 값을 11로, 지역변수 `lval`의 값을 25로 증가시켰기 때문에 증가된 상태로 복사가 이뤄짐.

* 다만 **`fork`** 함수의 반환 값의 차로 인해서 **`부모 프로세스`** 는 `lavl`의 값을 1 증가시키지만, 이는 **`자식 프로세스`** 의 `lval`에 영향을 미치지 않음. 마찬가지로 **`자식 프로세스`** 는 `gval`의 값을 1 증가시키지만, 이는 **`부모 프로세스`** 의 `gval`에 영향을 미치지 않음.
  
  +  **`fork`** 함수 호출 **이후**에는 **`두 프로세스가 동일한 코드를 실행하는 완전히 다른 프로세스가 되기 때문`**
