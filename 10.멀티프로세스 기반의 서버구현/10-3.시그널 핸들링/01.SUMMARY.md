프로세스의 생성 및 소멸방법에 대해 살펴보았는데, 아직 해결하지 못한 문제가 하나 남아있음.

  + **`도대체 자식 프로세스가 언제 종료될 줄 알고  waitpid 함수를 계속 호출하고 있느냐`**

따라서 이 문제의 해결책을 살펴봄. 

<br>

## 운영체제야! 네가 좀 알려줘

* **자식 프로세스** 종료의 인식주체는 운영체제임.

  + 따라서 운영체제가 열심히 일하고 있는 **부모 프로세스**에게 **다음과 같이** 이야기해줄 수 있다면 효율적인 프로그램 구현이 가능함.

  + **`부모 프로세스! 너가 생성한 자식 프로세스는 종료되었다!`**

* 그러면 **부모 프로세스**는 하던 일을 잠시 멈추고, **자식 프로세스**의 종료와 관련된 일을 처리하면 됨.

  + 이러한 시나리오의 프로그램 구현을 위해서 **`시그널 핸들링(Signal Handling)`** 이라는 것이 존재함.

    - 여기서 **`시그널`** 은 특정상황이 발생했음을 알리기 위해 운영체제가 프로세스에게 전달하는 메세지를 의미.

    - 그리고 그 메세지에 반응해서 메세지와 연관된, 미리 정의된 작업이 진행되는 것을 **`핸들링`** 또는 **`시그널 핸들링`** 이라 함.

<br>

## 시그널과 signal 함수

* 다음은 **시그널 핸들링**의 이해를 돕기 위한 프로세스와 운영체제의 대화 내용. 

```
프로세스 : 운영체제! 내가 생성한 자식 프로세스가 종료되면 zombie_handler라는 이름의 함수 좀 호출해줘!

운영체제 : 그래! 그럼 네가 생성한 자식 프로세스가 종료되면 네가 말한 zombie_handler라는 이름의 함수를 내가 대신 호출해줄 테니, 
          그 상황에서 실행해야 할 문장들을 그 함수에 잘 묶어둬!
```

* 위 대화 중 프로세스가 한 이야기가 **`시그널 등록`** 에 해당함.

  + 즉, 프로세스는 자식 프로세스의 종료라는 상황 발생시, 특정 함수의 호출을 운영체제에 요구하는 것. 

  + 이 요구는 다음 함수의 호출을 통해서 이뤄짐. (때문에 이 함수를 **`시그널 등록 함수`** 라 표현함.)

```C
#include <signal.h>

/* @return : 시그널 발생시 호출되도록 이전에 등록된 함수의 포인터 반환
 */
void (*signal(int signo, void (*func)(int)))(int);
```

* 위 함수는 반환형이 함수 포인터이다 보니, 선언이 다소 복잡해보임. 지금은 편의를 위해 위의 함수 선언을 다음과 같이 정리한다.

  + **함수 이름**　　　: **`signal`**

  + **매개변수 선언**　: **`int signo, void(*func)(int)`**

  + **반환형**　　　　: **`매개변수형이 int이고 반환형이 void인 함수 포인터`**

<br>

* 위 함수를 호출하면서 첫 번째 인자로 **특정 상황에 대한 정보**를, 두 번째 인자로 **특정 상황에서 호출될 함수의 주소 값(포인터)를 전달함.**
  
  + 그러면 **첫 번째 인자를 통해 명시된 상황 발생 시, 두 번째 인자로 전달된 주소 값의 함수가 호출됨.**

    - 참고로 **`signal`** 함수를 통해서 등록 가능한 특정 상황과 그 상황에 할당된 상수 몇몇을 정리해보면 다음과 같음.

      - **`SIGALRM`** 　: **`alarm`** 함수호출을 통해서 등록된 시간이 된 상황.

      - **`SIGINT`** 　 : CTRL+C가 입력된 상황

      - **`SIGCHLD`** 　: 자식 프로세스가 종료된 상황.

<br>

* 다음 요청에 해당하는 **`signal`** 함수의 호출문장을 만들어 보면 다음과 같다.

  - **자식 프로세스가 종료되면 mychild 함수를 호출해 달라**
  
    + 이때 mychild 함수는 매개변수형이 int이고 반환형이 void이어야 함. 그래야 **`signal`** 함수의 두 번째 전달인자가 될 수 있음.

    + 그리고 자식 프로세스가 종료된 상황은 상수 `SIGCHLD`로 정의되어 있으니, 이것이 **`signal`** 함수의 첫 번째 인자가 되어야 함.

    + 즉, **`signal`** 함수의 호출 문장은 다음과 같이 구성하면 됨.

      - `signal(SIGCHLD, mychild);`


<br>

* 이번에는 다음 두 가지 요청에 해당하는 **`signal`** 함수의 호출문장을 각각 만들어봄..

  - **`alarm` 함수호출을 통해서 등록된 시간이 지나면 timeout 함수를 호출해 달라.**
  
  - **CTRL+C가 입력되면  keycontrol 함수를 호출해 달라**

    + 이들 각각의 상황에 할당된 상수의 이름이 `SIGALRM`, `SIGINT`이니 다음과 같이 **`signal`** 함수의 호출 문장을 구성하면 됨.

      - `signal(SIGALRM, timeout);`

      - `signal(SIGINT, keycontrol);`

<br>

* 이렇게 시그널이 등록되면, 등록된 시그널 발생 시 (등록된 상황 발생시) 운영체제는 해당 시그널에 등록된 함수를 호출해 줌.


<br>

* **`alarm`** 함수는 다음과 같음.


```C
#include <unistd.h>

/* @return : 0 또는 SIGALRM 시그널이 발생하기까지 남아있는 시간을 초 단위로 반환
 */
unsigned int alarm(unsigned int seconds);
```

* 위 함수를 호출하면서 양의 정수를 인자로 전달하면, 전달된 수에 해당하는 시간(초 단위)이 지나서 `SIGALRM` 시그널이 발생함.

* 그리고 0을 인자로 전달하면 이전에 설정된 `SIGALRM` 시그널 발생의 예약이 취소됨.

 * 그런데 위의 함수호출을 통해서 시그널 발생을 예약만 해놓고, 이 시그널이 발생했을 때 호출되어야 할 함수를 지정하지 않으면 (**`signal`** 함수호출을 통해서) 프로세스가 그냥 종료되어 버림.

