프로세스의 생성 및 소멸방법에 대해 살펴보았는데, 아직 해결하지 못한 문제가 하나 남아있음.

  + **`도대체 자식 프로세스가 언제 종료될 줄 알고  waitpid 함수를 계속 호출하고 있느냐`**

따라서 이 문제의 해결책을 살펴봄. 

<br>

## 운영체제야! 네가 좀 알려줘

* **자식 프로세스** 종료의 인식주체는 운영체제임.

  + 따라서 운영체제가 열심히 일하고 있는 **부모 프로세스**에게 **다음과 같이** 이야기해줄 수 있다면 효율적인 프로그램 구현이 가능함.

  + **`부모 프로세스! 너가 생성한 자식 프로세스는 종료되었다!`**

* 그러면 **부모 프로세스**는 하던 일을 잠시 멈추고, **자식 프로세스**의 종료와 관련된 일을 처리하면 됨.

  + 이러한 시나리오의 프로그램 구현을 위해서 **`시그널 핸들링(Signal Handling)`** 이라는 것이 존재함.

    - 여기서 **`시그널`** 은 특정상황이 발생했음을 알리기 위해 운영체제가 프로세스에게 전달하는 메세지를 의미.

    - 그리고 그 메세지에 반응해서 메세지와 연관된, 미리 정의된 작업이 진행되는 것을 **`핸들링`** 또는 **`시그널 핸들링`** 이라 함.

<br>

## 시그널과 signal 함수

* 다음은 **시그널 핸들링**의 이해를 돕기 위한 프로세스와 운영체제의 대화 내용. 

```
프로세스 : 운영체제! 내가 생성한 자식 프로세스가 종료되면 zombie_handler라는 이름의 함수 좀 호출해줘!

운영체제 : 그래! 그럼 네가 생성한 자식 프로세스가 종료되면 네가 말한 zombie_handler라는 이름의 함수를 내가 대신 호출해줄 테니, 
          그 상황에서 실행해야 할 문장들을 그 함수에 잘 묶어둬!
```

* 위 대화 중 프로세스가 한 이야기가 **`시그널 등록`** 에 해당함.

  + 즉, 프로세스는 자식 프로세스의 종료라는 상황 발생시, 특정 함수의 호출을 운영체제에 요구하는 것. 

  + 이 요구는 다음 함수의 호출을 통해서 이뤄짐. (때문에 이 함수를 **`시그널 등록 함수`** 라 표현함.)

```
#include <signal.h>

/* @return : 시그널 발생시 호출되도록 이전에 등록된 함수의 포인터 반환
 */
void (*signal(int signo, void (*func)(int)))(int);
```
