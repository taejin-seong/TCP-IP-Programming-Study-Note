파일은 여는 것 못지않게 닫는 것이 중요한 것 처럼 마찬가지로 **프로세스도 생성 못지않게 소멸이 중요하다.** <br>

## 좀비(Zombie) 프로세스

* 프로세스가 생성되고 나서 할 일을 다 하면 (main 함수의 실행을 완료하면) 사라져야하는데 사라지지 않고 **좀비가 되어** 시스템의 중요한 리소스를 차지하기도 함.

* 이 상태에 있는 프로세스를 가리켜 **`좀비 프로세스`** 라 하는데, 이는 시스템에 부담을 주는 원인이 되기도 함.

* 때문에 `좀비 프로세스`를 소멸시켜야 함. 

<br>

## 좀비 프로세스의 생성이유

* **`fork`** 함수의 호출로 생성된 자식 프로세스가 종료되는 상황 두 가지를 예로 들면 다음과 같음.

  - 인자를 전달하면서 `exit`를 호출하는 경우

  - main 함수에서 return문을 실행하면서 값을 반환하는 경우

<br>

* `exit` 함수로 전달되는 인자 값과 main 함수의 return문에 의해 반환되는 값 모두 **운영 체제로 전달됨.** 

* 그리고 운영 체제는 이 값이 자식 프로세스를 생성한 부모 프로세스에게 전달될 때까지 자식 프로세스를 소멸시키지 않는데 **`바로 이 상황에 놓여있는 프로세스를 가리켜 좀비 프로세스라 함.`**

<br>

* 즉, **자식 프로세스를 좀비 프로세스로 만드는 주체는 운영체제 이다.**

* 이 좀비 프로세스는 언제 소멸이 될까? 답은 아래와 같음.

  - **`해당 자식 프로세스를 생성한 부모 프로세스에게 exit함수의 인자 값이나 return문의 반환 값이 전달되어야 함.`**

<br>

* 그렇다면 어떻게 부모 프로세스에게 값을 전달해야 할까? 

  - **부모 프로세스의 적극적인 요청이 있어야 (함수 호출이 있어야) 운영체제는 값을 전달해 줌.**

* **`반대로 말하면 부모 프로세스가 자식 프로세스의 전달 값을 요청하지 않으면, 운영체제는 그 값을 계속해서 유지하게 되고 결국 자식 프로세스는 좀비의 상태로 오랫동안 머물러 있어야함.`**

  - 결국 부모가 책임지고 자신이 낳은 자식을 거둬들어야 하는 셈.

<br>

* [zombie.c](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/blob/master/10.%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B8%B0%EB%B0%98%EC%9D%98%20%EC%84%9C%EB%B2%84%EA%B5%AC%ED%98%84/10-2.%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%26%20%EC%A2%80%EB%B9%84(Zombie)%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/zombie.c)를 실행하면 30초 멈추게 되는데 이 상태를 벗어나기 전에 자식 프로세스의 좀비 여부를 확인하면 아래와 같음.
<br>

<p align="center">
 <img src="https://user-images.githubusercontent.com/70312248/173108565-1fe13bca-5141-4b86-98d1-aa8e58255a5d.PNG" width="1920" height="720"/>  
</p>

<br>

* 위 출력결과를 통해서 PID가 27583인 프로세스의 상태가 **좀비(Z+)** 임을 알 수 있음. 참고로 30초의 대기시간이 지나서 부모 프로세스가 종료되면 PID가 27582인 부모 프로세스와 좀비가 된 프로세스가 함께 소멸되는 것을 확인할 수 있음.


<br>

## 좀비 프로세스의 소멸1 : wait 함수의 사용

* 자식 프로세스의 소멸을 위해서는 **부모 프로세스가 자식 프로세스의 전달 값을 요청해야 함.**

* 이를 위한 요청방법에는 두 가지 방법이 잇는데, 그 중 하나는 **다음 함수를 호출 하는 것.**

```C
#include <sys/wait.h>

/* @return : 성공 시 종료된 자식 프로세스 ID, 실패 시 -1 반환
 */
pid_t wait(int * statloc);
```
* 위 함수가 호출되었을 때, 이미 종류된 자식 프로세스가 있다면, 자식 프로세스가 종료되면서 전달한 값 (exit 함수의 인자 값, main 함수의 return에 의한 반환 값)이 매개변수로 전달된 주소의 변수에 저장됨. 

* 그런데 이 변수에 저장되는 값에는 자식 프로세스가 종료되면서 전달한 값 이외에도 **다른 정보가 함께 포함되어 잇으니, 다음 매크로 함수를 통해서 값의 분리 과정을 거쳐야 함.**

  - **`WIFEXTED`** : 자식 프로세스가 정상 종료한 경우 **참(true)** 을 반환함.
  
  - **`WEXITSTATUS`** : 자식 프로세스의 전달 값을 반환함.

* 즉 **`wait`** 함수의 인자로 변수 `status`의 주소 값이 전달되었다면, **`wait`** 함수의 호출 이후에는 다음과 같은 유형의 코드를 구성해야함.
```C
if (WIFEXTED(status)) // 정상 종료하였는가?
{
  puts("Normal termination!");
  printf("Child pass num: %d, WEXITSTATUS(status)); // 그렇다면 반환 값은?
}
```

* **`wait`** 함수호출을 통한 좀비 프로세스 소멸방법 예제는 [wait.c](https://github.com/taejin-seong/TCP-IP-Programming-Study-Note/blob/master/10.%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B8%B0%EB%B0%98%EC%9D%98%20%EC%84%9C%EB%B2%84%EA%B5%AC%ED%98%84/10-2.%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%26%20%EC%A2%80%EB%B9%84(Zombie)%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/wait.c)과 같음.

* **`wait`** 함수는 호출된 시점에서 종료된 자식 프로세스가 없다면, 임의의 자식 프로세스가 종료될 때까지 **블로킹 (Blocking) 상태** 에 놓인다는 특징이 있음.

  - 때문에 함수의 호출에 주의해야 함.

<br>

## 좀비 프로세스의 소멸2: waitpid 함수의 사용

*  **`wait`** 함수의 블로킹이 문제가 된다면 **`waitpid`** 함수의 호출을 고려하면 됨.

  - 이는 좀비 프로세스의 생성을 막는 두 번째 방법이자 **블로킹 문제**의 해결책이기도 함.

```C
#include <sys/wait.h>

/* @return : 성공 시 종료된 자식 프로세스 ID (또는 0), 실패 시 -1 반환
 * @param  :     pid : 종료를 확인하고자 하는 자식 프로세스 ID 전달, 이를 대신해서 -1을 전달하면 wait 함수와 마찬가지로 
 *                     임의의 자식 프로세스가 종료되기를 기다림.
 *           statloc : wait 함수의 매개변수 statloc과 동일한 의미로 사용됨.
 *           options : 헤더파일 sys/wait.h에 선언된 상수 WNOHANG을 인자로 전달하면, 
 *                     종료된 자식 프로세스가 존재하지 않아도 블로킹 상태에 있지않고, 0을 반환하면서 함수를 빠져 나옴.
 */
pid_t waitpid(pid_t pid, int * statloc, int options);
```
